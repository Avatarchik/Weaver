using System;
using System.IO;
using UnityEngine;
using UnityEditor;
using System.Reflection;

namespace Weaver
{
    /// <summary>
    /// Keeps track of the assembly path and if the
    /// weaving is enabled or not.
    /// </summary>
    [Serializable]
    public class WeavedAssembly
    {
        public delegate void WeavedAssemblyDelegate(WeavedAssembly weavedAssembly);

        [SerializeField]
        private string m_FilePath;
        [SerializeField]
        private bool m_Enabled;
        [SerializeField]
        private int m_LastWriteTime;
        private bool m_IsRelativePath;
        private bool m_IsValid;

        /// <summary>
        /// Creates a new empty instance of a Weaved Assembly. Should
        /// really only be used by Unity. 
        /// </summary>
        public WeavedAssembly()
        {
            m_Enabled = true;
            m_IsRelativePath = true;
        }

        /// <summary>
        /// Creates a new instance of a Weaved Assembly from a file path
        /// </summary>
        /// <param name="filePath">The relative path or system path of the assembly you want to weave</param>
        public WeavedAssembly(string filePath)
        {
            if (File.Exists(filePath))
            {
                m_IsRelativePath = false;
            }
            else if (File.Exists(RelativeToSystemPath(filePath)))
            {
                m_IsRelativePath = true;
            }
            else
            {
                throw new FileNotFoundException("The assembly could not be found at path '" + filePath + "'.");
            }

            m_FilePath = filePath;
            m_Enabled = true;
            m_IsValid = true;
            m_IsRelativePath = true;
            m_LastWriteTime = File.GetLastWriteTime(filePath).Second;
        }

        /// <summary>
        /// Creates a new instance of a Weaved Assembly from an
        /// Assembly instance. 
        /// </summary>
        /// <param name="assembly">The assembly you want to weave</param>
        public WeavedAssembly(Assembly assembly)
        {
            if (assembly == null)
            {
                throw new ArgumentNullException("We can't weave an assembly that is null.");
            }

            m_FilePath = assembly.Location;
            m_IsRelativePath = false;
            m_IsValid = true;
        }

        /// <summary>
        /// Returns back true if the assembly is
        /// valid and false if it's not. 
        /// </summary>
        public bool isValid
        {
            get { return m_IsValid; }
        }

        /// <summary>
        /// Returns back the file path to this assembly
        /// </summary>
        public string relativePath
        {
            get { return m_FilePath; }
            set { m_FilePath = value; }
        }

        /// <summary>
        /// Returns true if this assembly should be modified
        /// by Weaver or not. 
        /// </summary>
        public bool enabled
        {
            get { return m_Enabled; }
            set { m_Enabled = value; }
        }

        /// <summary>
        /// Returns back if this assembly is generated by Unity. 
        /// </summary>
        public bool IsUnityGenerated()
        {
            return m_FilePath.StartsWith("Library/ScriptAssemblies/");
        }

        /// <summary>
        /// Returns back if this assembly exists on disk.
        /// </summary>
        /// <returns></returns>
        public bool Exists()
        {
            return File.Exists(GetSystemPath());
        }

        /// <summary>
        /// Returns back the system path to this
        /// assembly. 
        /// </summary>
        public string GetSystemPath()
        {
            if (m_IsRelativePath)
            {
                return RelativeToSystemPath(relativePath);
            }
            else
            {
                return m_FilePath;
            }
        }


        /// <summary>
        /// Sees if this file has been modified since the last time we checked.
        /// </summary>
        /// <returns></returns>
        public bool HasChanges()
        {
            if (File.Exists(relativePath))
            {
                m_IsValid = true;
                int writeTime = File.GetLastWriteTime(relativePath).Second;
                if (m_LastWriteTime != writeTime)
                {
                    m_LastWriteTime = writeTime;
                    return true;
                }
            }
            else
            {
                m_IsValid = false;
            }
            return false;
        }

        /// <summary>
        /// Converts a relative path to a system path. 
        /// </summary>
        private static string RelativeToSystemPath(string relativePath)
        {
            // Get our path
            string path = Application.dataPath;
            // Get the length
            int pathLength = path.Length;
            // Split it
            path = path.Substring(0, pathLength - /* Assets */ 6);
            // Add our relative path
            path = Path.Combine(path, relativePath);
            // Return the result
            return path;
        }

        /// <summary>
        /// Returns back the relative path to the Unity project based off a
        /// system path.
        /// </summary>
        private static string SystemPathToRelativePath(string systemPath)
        {
            return FileUtil.GetProjectRelativePath(systemPath);
        }
    }
}
